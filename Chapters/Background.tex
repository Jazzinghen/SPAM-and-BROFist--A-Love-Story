\chapter{Background}
\label{chap:BG}

In questo capitolo parleremo del background tecnico e culturale che sta
dietro a questo progetto. Ci sar\'a spazio per una breve storia dei \nxt{}, 
delle veloci nozioni riguardanti il \PID{} ed \nxtOSEK{}.

\section{I MINDSTORMS e gli NXT}
I \nxt{} sono l'ultima incarnazione di una serie di prodotti creati
dalla \emph{Lego}, la quale affonda le sue radici da una serie di sensori
programmabili venduti prima del 1998 dalla \emph{Lego}.

\subsection{Storia dei Lego MINDSTORMS}
La prima versione
della serie si chiamava \RIS{} ed \'e stata rilasciata sul mercato nel
1998, seguita poi nel 2006 dalla versione \emph{MINDSTORMS NXT}. Nel 2009
\'e stata pubblicata l'ultima edizione, chiamata \emph{MINDSTORMS NXT 2.0}.

\graffito{Le origini, prima della \emph{Lego}}
La base hardware e software della prima versione dei \emph{Lego Mindstorms}
\'e derivata direttamente dal lavoro dell'\emph{MIT Media Lab}, i quali
avevano creato dei brick programmabili a scopo didattico. Questi erano stati 
programmati in \emph{Lego Logo} ed avevano un ambiente di sviluppo grafico
creato appositamente dalla \emph{Universit\'a del Colorado} nel 1994 con il
nome di \emph{LEGOSheets}.

\graffito{I vari contenuti dei kits dei \emph{Lego Mindstorms}}
Non tutte le versioni dei \emph{Lego Mindstorms} hanno avuto le stesse
dotazioni in campo di sensori e servo motori. La prima versione chiamata
\RIS{}, conteneva:
\begin{itemize}
    \item Due motori
    \item Due sensori di tocco
    \item Un sensore di luce
\end{itemize}    
La versione \emph{NXT} conteneva, invece:
\begin{itemize}
    \item Due \emph{Servo} Motori
    \item Un sensore di luce
    \item Un sensore di tocco
    \item Un sensore sonoro
    \item Un sensore di distanza ad ultrasuoni
\end{itemize}
L'ultima versione, infine, ha la stessa dotazione di quella precedente,
solo con due sensori di tocco, invece di uno soltanto, ed un sensore di
Colore al posto di quello di luce. 

\graffito{L'uso dei \emph{Lego Mindstorms} in campo didattico}
I \emph{Lego Mindstorms} sono derivati, come accennato sopra, da un applicazione 
di tipo didattico dell'\emph{MIT Media Lab}. Per questo la Lego ha deciso
di continuare a seguire questa idea proponendo alle scuole dei set
didattici chiamati \emph{Lego Mindstorms for Schools}. Questi set,
conosciuti anche come ``Challenge set'', differiscono da quelli in
commercio normalmente per un sensore di luce extra, alcuni ingranaggi in
pi\'u ed un software per la programmazione dei brick differente.

Questo software, chiamato ``ROBOLAB'', \'e basato sul software ``LabVIEW''
della \emph{National Instruments}, un ambiente di sviluppo per il
loro linguaggio di programmazione visivo per l'automatizzazione
industriale. Un altra scelta per la programmazione dei bricks \'e
l'utilizzo di firmware o linguaggi di programmazione di terze parti, tra i
quali anche linguaggi conosciuti come il \emph{C} o il \emph{JAVA}, i quali
vengono usati dai professionisti in campo di programmazione embedded.

\subsubsection{L'origine del nome \emph{Mindstorms}}
I \emph{Lego Mindstorms} devono il loro nome al titolo del libro
``Mindstorms: Children, Computers, and Powerful Ideas''\cite{bib:mindbook},
scritto da \emph{Seymour Papert}, uno dei pionieri dell'Intelligenza
Artificiale ed inventore del \emph{LOGO}. In questo libro Papert proponeva
un ambiente di studio basato sui computer chiamato \emph{il Micromondo}.

Questo Micromondo doveva completare il metodo di costruzione della
conoscenza dei bambini, conosciuto come \emph{Approccio Costruttivista
all'insegnamento ed al sapere}.

Siccome i \emph{Lego Mindstorms} hanno alla base proprio questa idea
perci\'o la \emph{Lego} ha deciso di utilizzare questo
nome\cite{bib:mindbarticle}.

\subsection{Lego MINDSTORMS - RCX}
La prima versione dei \emph{Lego Mindstorms} aveva come base il brick
conosciuto come \emph{RCX}.

\subsubsection{Specifiche tecniche dell'RCX}
Gli RCX contengono un microcontroller 
\emph{Renesas H8/300} come CPU ed una memoria RAM di 32KB. L'unica
interfaccia di comunicazione con il PC o gli altri RCX \'e una porta
\emph{InfraRed} (IR). Questo rende impossibile l'upload di programmi
sull'RCX con metodi differenti da un'interfaccia proprietaria IR per la
quale esistono drivers solo per Windows e MAC. \'E possibile caricare
programmi anche in ambiente \emph{*NIX}, utilizzando per\'o metodi
differenti, quali il compilatore per \emph{Not Quite C}.

La connessione IR permette, inoltre, la comunicazione con una serie di
altri prodotti della \emph{Lego}, listati sotto. Le comunicazioni hanno una
\emph{Carrier Frequency} di 38.5kHz nella verione 1.0 e di 75kHz nella
versione 2.0, la quale viene generata dai timer interni dell'RCX.

Oltre alla porta IR sono presenti tre porte per i sensori, tre per i
motori ed un LCD sul quale si poteva leggere la carica della batteria, lo
stato di motori e sensori, il programma in esecuzione oppure quale
programma era in esecuzione al momento.

Oltre a motori e sensori la Lego aveva messo in commercio anche una
telecamera in collaborazione con la \emph{Logitech}. Questa, per\'o, non
era collegata direttamente al brick RCX, bens\'i aveva bisogno di venir
collegata ad un PC.

\graffito{Alimentazione degli RCX}
I programmi, sull'RCX, vengono mantenuti sulla memoria RAM, quindi ogni
volta che veniva spento il brick questi vengono cancellati ed vanno
ricaricati sul brick. Questo problema, nella versione 1.0 degli RCX, \'e
risolto grazie alla presenza di un jack per la connessione ad un
caricatore. Nelle versioni successive, comunque, la connessione alla
corrente elettrica \'e stata rimossa. Grazie alla presenza del jack per la
connessione alla corrente i brick RCX sono diventati popolari tra gli
appassionati di modellismo come centro di controllo per trenini della lego.

\subsubsection{Linguaggi di programmazione per RCX}
Ci sono vari linguaggi utilizzabili per la programmazione degli RCX, oltre
a quelli ufficiali, \emph{RCX Code} e \emph{ROBOLAB}. Quelli pi\'u
importanti sono:
\begin{description}
    \item[NXTGCC]una toolchain di compilazione per C ed Assembly che
        permette la creazione di firmware da caricare su di un'unit\'a RCX
    \item[leJOS]che permette l'utilizzo di Java
    \item[Visual Basic]tramite l'utilizzo dell'interfaccia \emph{COM+}
        fornita nel CD dei \RIS{}
    \item[NXC]che \'e un linguaggio Open Source simile al C
    \item[XSLisp]che \'e un implementazione di \emph{LISP} per RCX ed NXT
\end{description}

\subsection{Lego MINDSTORMS - NXT}
Nel 2006 la Lego ha messo sul mercato la seconda versione dei \emph{Lego
Mindstorms}: I \nxt{}.

Questa nuova incarnazione deli \emph{Lego Mindstorms} era basata sulla
stessa idea, solo che il brick fu radicalmente cambiato ad una versione
pi\'u potente.

\subsubsection{Specifiche tecniche dell'NXT}
Il brick \'e un micro computer basato su un microcontrollore della
\emph{ATMEL} che ha come processore un \emph{ARM7}, il quale, a temperature
standard, ha un clock di circa 100MHz, mentre a temperature industriali,
nel caso peggiore, arriva ad un clock di 55MHz. Inoltre ha una memoria
flash di 256KB ed una memoria volatile di tipo SRAM da 64KB.

\graffito{Comunicazioni tra device e con l'utente}
Le comunicazioni con altri device (PC o NXT) vengono fornite da un
controller \emph{USB 2.0 High Speed} e da uno \emph{Bluetooth}, inoltre una
delle porte RJ12 per i sensori (la numero 4, per essere precisi) \'e una
porta \emph{RS-485 Capable}.

Le comunicazioni con l'utente avvengono attraverso l'uso di un display LCD
di tipo \emph{Dot Matrix} della dimensione di 100x64 pixel. \'E anche
disponibile uno speaker monoaurale che pu\'o riprodurre dei file audio con
un sampling rate di 8kHz.

\graffito{Differenze tra gli NXT e gli NXT2.0}
Nella versione attuale gli \nxt{} non hanno differenze nel brick. L'unica
differenza \'e la presenza di un sensore di colore al posto di quello di
luce.

\graffito{Alimentazione degli NXT}
Come le versioni 1.5 e 2.0 degli RCX anche gli NXT non hanno una presa per
l'alimentazione esterna. L'alimentazione viene fornita da sei batterie
stilo di tipo AA, permettendo quindi l'uso di batterie ricaricabili. Nelle
versioni didattiche venivano per\'o fornite delle batterie ricaricabili a
ioni di Litio ed un alimentatore. Queste batterie sono acquistabili anche
dal negozio online della \emph{Lego}.

\subsubsection{Linguaggi di programmazione per gli NXT}
Due sono i metodi per programmare un brick NXT che vengono forniti
gratuitamente dalla Lego sia nei kit ``retail'' che in quelli
``didattici'':
\begin{itemize}
    \item Creare dei semplici programmi direttamente sul men\'u
        dell'NXT, i quali per\'o, sono limitati a 5 comandi.
    \item Creare dei programmi utilizzando il sistema fornito dalla Lego
        chiamato NXT-G. Questo software di programmazione visiva \'e
        derivato da \emph{LabView} della \emph{National Instruments} e
        fornisce della programmazione di box di controllo.

        Non permette una programmazione avanzata, cosa che invece fornisce
        un Toolkit a pagamento fatto apposta dalla \emph{National
        Instruments} per \emph{Labview}
\end{itemize}

Questi metodi, per\'o, non forniscono dei veri linguaggi di programmazione,
bens\'i dei sistemi di programmazione visuale che non permettono la
creazione di programmi complessi quanto quelli che ci si aspetterebbe da
una piattaforma di tipo embedded.

Per questo sono presenti un gran numero di alternative, create
appositamente per utilizzare i linguaggi usati in campo professionale,
oppure per sembrare tali:
\begin{description}
    \item[nxtOSEK]\'e un ambiente basato su standard \emph{OSEK} che
        permette la programmazione in C/C++ su brick NXT. Questo \'e il
        sistema che \'e stato scelto per questo progetto grazie alla
        flessibilit\'a ed alla vicinanza con il mondo dello sviluppo di
        sistemi embedded.
    \item[NBC, NXC e BricxCC]formano un ambiente di sviluppo ``Open
        Source''. Il termine \'e stato messo tra virgolette in quanto sia
        NBC che NXC, i due linguaggi derivati, il primo da Assembly ed il
        secondo da C, vengono distribuiti Open Source, mentre l'ambiente di
        sviluppo, BricxCC, viene distribuito come Freeware.

        Quest'ultimo fornisce vari strumenti quali:
        \begin{itemize}
            \item[-]NeXTExplorer, per la gestione di files sulla memoria
                dell'NXT o per la sua deframmentazione
            \item[-]Un HEX editor
            \item[-]NeXTScreen, un visualizzatore di ci\'o che viene
                mostrato sullo schermo dell'NXT
        \end{itemize}
    \item[leJOS NXJ]\cite{bib:lejos}\'e un linguaggio di alto livello
        basato su Java che usa un firmware custom sviluppato dal team leJOS
    \item[ROBOTC]\cite{bib:robotc}\'e un linguaggio basato su C con un
        ambiente di sviluppo per Windows ed \'e l'unico che fornisce un
        debugger in real-time.
        Il problema \'e che questo sistema non solo richiede l'uso di
        Windows in quanto non \'e compilabile al di fuori della propria
        IDE, ma \'e anche a pagamento.

        \'E comunque stato citato come il miglor sistema per insegnare il C
        attraverso la programmazione di NXT\cite{bib:rcarticle}.
\end{description}

\section{nxtOSEK}
\image  {Images/nxtOSEKStruct}
        {La struttura del sistema \nxtOSEK{}}
        {.8}
        {img:nxtosekstr}
Per questo progetto, tra le scelte disponibili, \'e stato scelto di usare
la piattaforma Open Source \nxtOSEK{}. Questa scelta \'e stata influenzata
da vari fattori, tra i quali:
\graffito{Le scelte che hanno portato all'utilizzo di \nxtOSEK{}}
\begin{itemize}
    \item I programmi per questa piattaforma possono venir scritti sia in C
        che in C++.

        Questo \'e molto differente rispetto alle altre alternative in
        quanto nella maggior parte dei progetti embedded vengono utilizzati
        uno di questi linguaggi di basso livello assieme ad
        \techname{assembly}.

        Questo grazie ad una toolchain GCC per la compilazione di file
        \techname{.rxe}, cosa, tra l'altro, che rende il progetto
        completamente cross-plataform\footnote{Si faccia riferimento al
        paragrafo \ref{sec:nxtoseklinux} per vedere quali accorgimenti
        sono stati presi per utilizzare \nxtOSEK{} sotto Linux.}, sebbene
        non proprio ``out of the box''.
    \item \nxtOSEK{} è basato sui sistemi realtime multitask
        \techname{TOPPERS/OSEK[ATK]} e \techname{TOPPERS/JSP}, i quali
        seguono, rispettivamente, le specifiche \techname{OSEK/VDX} e
        \techname{$\mu$ITRON 4.0}.

        Questo fornisce, a differenza degli altri sistemi, una piattaforma
        ancora più vicina all'industria di sistemi Embedded, in quanto
        \techname{OSEK/VDX} viene utilizzato nella produzione di sistemi di
        controllo per automobili, mentre \techname{$\mu$ITRON 4.0}
        rappresenta uno standard aperto industriale giapponese nel campo dei
        sistemi embedded.
    \item I device drivers sono stati ricavati dal progetto \techname{NXJ}
        del team \emph{leJOS}, i quali sono più affidabili di quelli
        proposti in un altro progetto scritto in C: \techname{nxOS}.

        Sfruttando un \PID{} c'era la necessità di aver pieno controllo sui
        motori, facendoli ruotare a velocità anche molto basse. Purtroppo
        i device drivers di \techname{nxOS} non permettevano la rotazione
        con una potenza in input al di sotto del 50\%.

        Inoltre \nxtOSEK{} permette l'utilizzo di un gran numero di sensori
        di terze parti che potrebbero rivelarsi utili a chiunque ne abbia
        accesso.
\end{itemize}

\subsection{Struttura di un programma per nxtOSEK}
La scrittura di un programma per \nxtOSEK{} è quasi completamente identico
alla scrittura di un programma in C, bisogna scrivere un file che sarà
quello principale, al quale possono venir inclusi vari headers, puntanti ad
altri file sorgente contenenti le varie funzioni utilizzate nel codice.

\graffito{Task OSEK}
Quello che differisce dal C è la necessità di dichiarare i \techname{Task}
che verranno eseguiti con un tempo periodico da \nxtOSEK{}. Questi devono
venir definiti all'interno di un file, che verrà poi dichiarato all'interno
del \cypher{Makefile}, utilizzando le specifiche dell'\emph{OSEK
Implementation Language}\cite{bib:OIL}.

Il file si presenta con una struttura simile a quella riportata nell
riquadro \ref{lst:sampleoil}, alla quale bisogna aggiungere i vari task.

Ognuno di questi Task ha le proprie caratteristiche ben definite, tra le
quali la priorità d'esecuzione (\cypher{PRIORITY}), la dimensione dello
stack allocato per quel Task (\cypher{STACKSIZE}) oppure ancora se il Task
debba partire automaticamente o meno (\cypher{AUTOSTART}).

\begin{figure*}[htbp]
    \begin{lstlisting}[caption=Sample \emph{OIL} file,
                       label=lst:sampleoil]
#include "implementation.oil"

CPU ATMEL_AT91SAM7S256
{
    OS LEJOS_OSEK
    {
        STATUS = EXTENDED;
        STARTUPHOOK = TRUE;
        ERRORHOOK = FALSE;
        SHUTDOWNHOOK = FALSE;
        PRETASKHOOK = TRUE;
        POSTTASKHOOK = FALSE;
        USEGETSERVICEID = FALSE;
        USEPARAMETERACCESS = FALSE;
        USERESSCHEDULER = FALSE;
    };

    APPMODE appmode1{}; 

    RESOURCE lcd
    {
        RESOURCEPROPERTY = STANDARD;
    };

  	COUNTER SysTimerCnt
  	{
    	MINCYCLE = 1;
    	MAXALLOWEDVALUE = 10000;
    	TICKSPERBASE = 1;
  	};

//... Tasks Declarations

//... Tasks' Alarms

}
    \end{lstlisting}
\end{figure*}
Ognuno di questi task, inoltre, può venir collegato ad un allarme periodico
che può venir utilizzato per settare un evento, richiamare una callback
oppure, come già accennato, attivare un Task.

Un esempio di come sia collegato un Task ad un allarme periodico è
riportato nel riquadro \ref{lst:oiltskalarm}
\begin{figure*}[htbp]
    \begin{lstlisting}[caption=Sample Task-Alarm declaration,
                       label=lst:oiltskalarm]
TASK PID_Controller
{
    AUTOSTART = FALSE;
    PRIORITY = 3;
    ACTIVATION = 1;
    SCHEDULE = FULL;
    STACKSIZE = 512;
};

//  ... Other Tasks

ALARM PID_alarm
{
    COUNTER = SysTimerCnt;
    ACTION = ACTIVATETASK
    {
        TASK = PID_Controller;
    };
    AUTOSTART = TRUE
    {
        ALARMTIME = 1;
        CYCLETIME = 5;  // 5ms run time
        APPMODE = appmode1;
    };
};
    \end{lstlisting}
\end{figure*}

\graffito{Utilizzo dei Task dentro il codice C}
Una volta dichiarati i Task utilizzando il linguaggio d'Implementazione
\emph{OSEK} bisogna collegare le parti del nostro programma a queste
dichiarazioni.

Ad ogni task bisogna ricollegare una parte di programma che verrà eseguita
proprio come una funzione senza parametri, in quanto il richiamo di un
Task, in codice C, viene scritto come: \codeconst{TASK(TaskName)\{\};}.
Inoltre bisogna informare l'intero programma della presenza delle varie
\emph{risorse} disponibili, tra le quali task, allarmi e risorse. Questo
viene fatto prima della dichiarazione di un qualsiasi Task utilizzando la
forma \codeconst{DeclareTask(TaskName);}.

Questo porta ad un problema principale, ovvero la mancanza di passaggio
d'informazioni di contesto. Per risolvere questo problema bisogna
utilizzare, per quanto rischioso, delle variabili globali.

Meritano di venir menzionate, inoltre, tre funzioni che fanno parte delle
API di \nxtOSEK, quella di inizializzazione (\codeconst{void
ecrobot\_device\_initialize()\{\}}), quella di finalizzazione
(\codeconst{void ecrobot\_device\_terminate()\{\}}) e quella che va
chiamata da un interrupt di tipo 2 dall'\emph{ISR} (\codeconst{void
user\_1ms\_isr\_type2(void)\{\}}).

Un programma, dunque, avrà una forma tipo quella mostrata nel riquadro
\ref{lst:sampnxtc}.

\begin{figure*}[htbp]
    \begin{lstlisting}[caption=Sample \nxtOSEK{} C structure,
                       label=lst:sampnxtc]
// Includes

/*-----------------------------------------------------*/
/* OSEK declarations                                   */
/*-----------------------------------------------------*/
DeclareCounter(SysTimerCnt);
DeclareResource(lcd);
DeclareTask(BRO_Comm);
DeclareTask(PID_Controller);
DeclareTask(Speed_Updater);
DeclareTask(DisplayTask);

void ecrobot_device_initialize()
{
//  ...
}

void ecrobot_device_terminate()
{
//  ...
}

void user_1ms_isr_type2(void)
{
//  ... Type 2 Interrupt Function (Normally in here we stop
//  ... nxtOSEK when the "left button" is pressed on the NXT
//  ... Brick
}

TASK(PID_Controller)
{
//  ...
}

//  All the other Tasks
    \end{lstlisting}
\end{figure*}

\subsection{Compilazione delle applicazioni per nxtOSEK}
Ogni volta che viene compilato un programma per nxtOSEK avvengono i
seguenti passi:
\begin{enumerate}
    \item Vengono compilate le prime parti del sistema \nxtOSEK{}, tra cui
        i sistemi di controllo di allarmi, interrupt ed eventi
    \item Viene creato un file di configurazione per il Kernel di
        \nxtOSEK{} da un parser per file \techname{.oil}, chiamato
        \emph{sg.exe}, il quale interpreta il file di configurazione
        contenente le dichiarazioni delle risorse per il nostro programma.
    \item Viene quindi compilato il resto di \nxtOSEK{} che richiedeva le
        dichiarazioni dei Task, assieme al programma
    \item Vengono assemblati i file \techname{.s} richiesti dal sistema,
        quali il supporto per vettori, l'\emph{IRQ} ed il sistema di
        gestione degli \emph{Entry Points}
    \item Infine vengono generate le immagini binarie che verranno poi
        caricate sul Brick NXT.
\end{enumerate}

\subsection{nxtOSEK in ambiente Linux} \label{sec:nxtoseklinux}
Purtroppo, come scritto sulla pagina delle FAQs del progetto
\nxtOSEK{}\cite{bib:nxtOSEKFAQs}, non esiste una procedura comoda per
compilare e caricare su NXT i programmi scritti per \nxtOSEK{}.

Seguendo la guida presente nel sito\cite{bib:linuxinst}, comunque, è
possibile fare in modo che la compilazione funzioni anche attraverso l'uso
di \techname{Wine}, in quanto il file per il parsing dei file
\techname{OIL} è un eseguibile per Windows del quale non sono state
rilasciate le specifiche.

Inoltre, per la compilazione, sarà necessario settare correttamente tutti i
path all'interno del file \cypher{ecrobot.mak}, in quanto gli strumenti
usati sono vari e non è stato predisposto un metodo per l'utilizzio di
variabili d'ambiente.

\graffito{Upload di immagini su un unità NXT}
Per l'upload delle immagini sull'unità \emph{NXT} si fa necessario
l'utilizzo di \techname{NeXTTool}. Per compilare e far girare questa
applicazione sotto Linux bisogna anche scaricare il compilatore per
\emph{Turbo Pascal}.

\section{PID Digital Controller}
Il \PID{} è un sistema di controllo ciclico per i motori largamente
utilizzato in applicazioni Industriali.

\image  {Images/PID}
        {Schematizzazione della struttura del Digital PID Controller}
        {.8}
        {img:PID}

\'E un sistema che fa uso dei dati ricevuti dai motori per regolarne la
potenza ad intervalli regolari e farli andare alla velocità desiderata. Lo
schema generico è rappresentato nell'immagine \ref{img:PID}. Il nome
\emph{PID} deriva dall'utilizzo dei dati in maniera sia in maniera
Proporzionale che in maniera Integrativa e Derivativa.

La parte Proporzionale determina la reazione del sistema all'errore
istantaneo, quella Integrativa determina la reazione del sistema rispetto
alla somma degli errori negli stati precedenti, mentre quella Derivativa
ne determina la reazione in base a quanto velocemente l'errore cambia.

I dati utilizzati da questo tipo di controller sono:
\begin{itemize}
    \item Le potenze applicate negli ultimi tre intervalli di tempo nei
        quali è stato utilizzato il \emph{PID}
    \item I $\Delta$V rispetto alla velocità target impostata negli ultimi
        tre intervalli di tempo.
    \item Una serie di costanti numeriche scelte \emph{ad hoc} in base alle
        specifiche Hardware della piattaforma sulla quale andrà
        implementato il \PID{}
\end{itemize}

Questo sistema, in base alle costanti numeriche, richiede un certo tempo
per raggiungere la velocità richiesta e quindi stabilizzarsi su di essa,
ottenendo così l'effetto desiderato.

\cleardoublepage
