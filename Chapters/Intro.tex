\chapter{Introduzione}
\label{chap:Intro}

\section{I Sistemi Embedded}

\graffito{I Sistemi Embedded nella vita di tutti i giorni}
Negli ultimi tempi le vere rivoluzioni tecnologiche si sono sempre
dimostrate quelle riguardanti l'integrazione di device nella vita di tutti
i giorni senza che le persone che ne usufruiscono si accorgano della loro
presenza. Basta pensare alla enorme quantit\'a di device con la quale
siamo abituati a convivere, quali navigatori satellitari che stanno nel
palmo della mano, integrati all'interno degli smartphone, ormai
potenti quanto PC, oppure alla presenza di sistemi di controllo
elettronici per la stabilit\'a all'interno delle macchine.

Questi oggetti fanno parte di una categoria di sistemi
microprogrammati, noti come \newterm{Sistemi Embedded}, creati per eseguire
un numero limitato di specifiche funzioni. L'applicazione di questa
tecnologia spazia dalla robotica all'Entertainment portatile, dalla
medicina alle applicazioni militare, dunque si fa sempre pi\'u
necessario avere competenze
in questo campo, in quanto la richiesta \'e destinata ad aumentare,
come aumenter\'a la necessit\'a di avere strumentazioni tecnologiche sempre
pi\'u integrate nella vita di tutti i giorni, senza che l'utente finale si
accorga della loro presenza.

\section{Programmare i Sistemi Embedded}

Programmare applicazioni per questi sistemi pu\'o essere
estremamente complicato, soprattutto per coloro che sono meno esperti nella
programmazione o che sono abituati a produrre software per piattaforme di
alto livello.

\graffito{Le difficolt\'a derivanti dalla programmazione di software per sistemi
Embedded} Il problema derivante dalla programmazione di software per
sistemi Embedded \'e la necessit\'a di lavorare con risorse limitate.
Questo limita il livello di astrazione dei linguaggi di programmazione:
il programmatore necessita di competenze specifiche in linguaggi di basso
livello.
Il debugging di questo tipo di piattaforme, inoltre, pu\'o essere
complicato o impossibile: potrebbero non essere disponibili
periferiche di comunicazione diretta oppure metodi per
recuperare file di log direttamente dalla memoria del sistema.

Sviluppare le abilit\`a necessarie per programmare correttamente su questo
tipo di piattaforme pu\`o richiedere molto tempo. Per questo motivo \`e
utile disporre di una piattaforma di sviluppo sulla quale la
programmazione risulti pi\`u astratta e semplice, a cui venga demandata la
generazione dell'effettivo codice a basso livello. Tale approccio porta
due principali benefici:

\begin{itemize}

\item   Permette all'utente di sviluppare software pur senza richiedere
        competenze in programmazione;

\item   Costituisce una base di partenza per un programmatore inesperto
        che intraprende uno studio nel campo della programmazione
        Embedded.

\end{itemize}

\graffito{L'idea alla base}
L'idea \`e dunque quella di creare un set di strumenti che permettano di
spostare
lo sviluppo di software su un'applicazione di modellazione e simulazione
di sistemi dinamici, pur mantenendo un feedback istantaneo da parte della
piattaforma hardware.

Questo differisce dal metodo tradizionale di modellazione: nel caso di un
robot, per esempio, questo permette l'utilizzo di dati influenzati da
fattori esterni, quali la carica della batteria dell'unit\'a, l'attrito
intrinseco dei singoli motori, la presenza di ostacoli e cos\'i via.
Un software sviluppato in questo modo fa riferimento a \foreignword{real
case scenarios}.

In un ambiente di sviluppo tradizionale, al contrario, \`e necessario
introdurre degli elementi esterni ``fittizi'', oppure scrivere il codice
relativo al modello creato, testarlo sulla piattaforma Embedded,
registrare i dati per una seconda analisi e modificare il modello fino a
convergere ad una versione definitiva.

\section{Scelta degli strumenti}

In tutti i campi di applicazione delle Scienze Informatiche, la scelta di
strumenti di sviluppo corretti \'e un punto particolarmente cruciale.
In ambito Embedded questo riguarda non solo la piattaforma
\foreignword{software}, ma anche quella \foreignword{hardware}. Nel nostro
caso un'ulteriore opzione riguarda il \emph{pacchetto di modellazione e
simulazione di sistemi dinamici}.

Una volta effettuate tutte queste scelte, sar\`a necessario sviluppare un
sistema di interfacciamento della piattaforma Embedded con il software
di simulazione.

\subsection{La piattaforma Hardware}

Per quanto riguarda l'hardware \`e stato necessario individuare la
piattaforma che facilita maggiormente l'acquisizione di competenze
basilari nella programmazione Embedded.

Come accennato precedentemente l'idea che sta alla base dei sistemi
Embedded \'e la focalizzazione delle piattaforme hardware su un compito
specifico, tuttavia progettare specificatamente una piattaforma per lo
scopo prefissato sarebbe una spesa eccessiva.

\subsubsection{\nxt}

La scelta pi\`u naturale, seguendo criteri di basso costo e ampia
disponibilit\`a, \`e ricaduta sui \nxt.

Questa linea di prodotti della \lego \`e stata ideata per la costruzione di
robot e altri sistemi automatici o interattivi. \graffito{ATMEL
AT91SAM7S256} I \nxt{} contengono un \foreignword{microcontroller
multi-purpose} \techname{ATMEL} \techname{AT91SAM7S256}, piattaforma che
dispone di:

\begin{itemize}
\item Connessione \techname{USB};
\item Controller Bluetooth;
\item \foreignword{Bus} \isquarec{} per la comunicazione interna;
\item Connessione seriale \techname{RS485} (utilizzabile, tra gli altri
      possibili scopi, per la comunicazione tra \nxt).
\end{itemize}

La piattaforma \techname{AT91SAM7S256} \'e basata su un processore
\techname{ARM7}. Oltre ad essere facilmente reperibile, essa \`e stata e
viene tutt'ora utilizzata in vari prodotti distribuzione, quali:
\graffito{L'uso del processore ARM7 sul mercato}
\begin{itemize}
    \item \techname{Sega Dreamcast}
    \item \techname{Apple iPod}
    \item \techname{Nintendo DS} e \techname{Nintendo GBA}
    \item La maggior parte dei telefoni portatili della \emph{Nokia}
    \item Una gran quantit\'a di modelli di automobili.
\end{itemize}

Inoltre i \nxt{} vengono spesso utilizzati per scopi didattici in scuole 
e musei di scienze. In questi ambiti \`e molto popolare l'interfaccia di
programmazione visuale fornita di serie dalla \lego, la quale per\`o
risulta completamente inadeguata allo sviluppo di qualsivoglia programma
non banale.

\subsubsection{Periferiche disponibili per l'NXT}

Un altro punto forte dei \nxt{} \'e la disponibilit\'a di una vasta gamma
di sensori, inclusi nella confezione base, con i quali il software \`e in
grado di interagire con il mondo esterno:

\begin{itemize}
\item   Sensori di contatto binari;
\item   Sensori di luminosi\`a;
\item   Sensori acustici;
\item   Dispositivo \foreignword{sonar} a ultrasuoni;
\end{itemize}

\subsection{La piattaforma Software}

Una volta deciso su quale piattaforma hardware operare, occorre selezione
una delle varie varie alternative tra le molte piattaforme software
disponibili.

Le scelte vagliate sono state fondamentalmente tre:
\begin{description}
    \item[nxOS]\cite{bib:nxos} un sistema operativo per \nxt{} scritto da
    David Anderson. Purtroppo lo sviluppo comunitario di tale sistema
    appare abbandonato dal giugno del 2009.
    \item[NBC \& NXC]\cite{bib:nbcnxc} due firmware implementanti
    rispettivamente un linguaggio \techname{Assembly-like} ed un dialetto
    del \techname{C}.
    \item[nxtOSEK] un sistema operativo conforme allo standard
    \techname{OSEK} \cite{bib:osek} e sviluppato da Takashi Chikamasa.
\end{description}

Da questo punto di vista un ottimo indice di bont\`a \`e l'affidabilit\`a
dei \foreignword{device drivers} di sensori e servomotori: dopo svariati
test effettuati su queste piattaforme software, la scelta \'e ricaduta sul
sistema \techname{nxtOSEK}.

\subsubsection{Il sistema \nxtOSEK}

Il sistema operativo \nxtOSEK{}\cite{bib:nxtosek} \`e costituito
dall'unione dei device drivers in C/Assembly di \techname{LeJOS NXJ} (un
firmware di rimpiazzo per i \nxt{} basato su \techname{Java}) con il core
\techname{Toppers}.

\begin{description}
    \item[TOPPERS/ATK](conosciuto anche come \techname{TOPPERS/OSEK}), 
        fornisce primitive di \foreignword{multithreading real-time}
        conforme alla specifica \techname{OSEK};
    \item[TOPPERS/JSP]fornisce primitive analoghe conformi con le
        specifiche giapponesi \emph{$\mu$ITRON}\cite{bib:muitron}.
\end{description}

Grazie all'unione di queste features e all'utilizzo di una
\foreignword{toolchain} \techname{GCC} per \techname{ARM},
\techname{nxtOSEK} fornisce un ambiente di sviluppo Real Time in Ansi
\techname{C / C++}.

Per quanto funzionante, questo sistema operativo \`e tutt'altro che
perfetto, ma si rivela essere comunque la miglior scelta tra quelli
disponibili: i linguaggi supportati sono diffusi e ben conosciuti tra i
professionisti, dunque non \`e necessario un \foreignword{training}
specifico per sviluppare applicazioni. In pi\`u, fatta eccezione per parte
del sistema di compilazione, il sistema \`e completamente
\foreignword{Open Source}.

\subsection{Ambiente di Sviluppo Grafico}

Come menzionato precedentemente, la programmazione di basso livello su
piattaforme Embedded \'e complicata e, soprattutto, richiede un gran
numero di \foreignword{trial and error} con un \foreignword{feedback}
minimo da parte della piattaforma. Per questo motivo risultano
apprezzabili sia un sistema semplice ed intuitivo per la realizzazione di
applicazioni che un meccanismo per il logging di ci\'o che accade
sull'unit\'a NXT.

\subsubsection{Uno strumento di Modellazione e Simulazione}

In molti contesti di ricerca, la simulazione e la progettazione di
sistemi Embedded viene affidata al software \techname{Matlab}, un ambiente
per la computazione numerica. Questo viene in genere affiancato a
\techname{Simulink}, un pacchetto per la modellazione e la simulazione di
sistemi Dinamici ed Embedded.

Questo connubio permette ai professionisti della modellizzazione teorica di
sistemi elettronici di creare dei modelli per piattaforme Embedded, che
vengono successivamente testati senza dover scrivere il codice. Ci\`o
elimina la necessit\'a di competenze in programmazione.

\graffito{L'uso di \techname{SciCosLab}}
Sfortunatamente \techname{Matlab} viene distribuito a pagamento e con
licenza proprietaria, caratteristiche che non sempre sono accettabili in
un contesto accademico. In linea con il resto del progetto, esiste
comunque un'alternativa \foreignword{OpenSource} a \techname{Matlab} e
\techname{Simulink}, che rispettivamente possono essere sostituiti da
\techname{SciLab} e \techname{SciCosLab}.

\section{Implementazione}

Come a questo punto risulter\`a lampante, il lavoro descritto in questo
documento \`e stato incentrato sull'estensione del sistema
\techname{SciCosLab}, finalizzata all'inserimento di funzionalit\`a di
controllo remoto e raccolta dati sulla piattaforma Embedded \nxt.

Prima di inoltrarci nei dettagli tecnici dei capitoli successivi,
introdurremo, in una veloce panoramica, i vari sottoproblemi che sono
stati affrontati prima di poter attuare l'estensione di cui sopra.

\subsection{Lettura dei dati}

In \nxtOSEK{} come negli altri sistemi operativi testati, la comunicazione
attraverso il canale \techname{USB} risulta possibile solo in scrittura
(da computer a NXT). Come diretta conseguenza, \`e possibile comunicare al
robot le operazioni da eseguire, ma non si possono ottenere i dati rilevati
dai sensori. Operazioni comuni come il \foreignword{fine tuning} degli
attuatori e \foreignword{debug} ne risultano estremamente penalizzate.

Per questa ragione si \`e reso necessario lo sviluppo di un protocollo di
trasmissione basato su \techname{BlueTooth} col quale ottenere una
comunicazione bidirezionale.

\graffito{BROFist}Questo protocollo incorpora un formato binario per la
specificazione di comandi per il controllo dei servo motori e dei sensori,
cos\'i da poter costituire un radiocomando basato su computer.

A questo protocollo ho dato il nome di \BROFist{}: BROFist - Robot
Operational Fist, che sta ad indicare il rapporto di fratellanza che si
crea tra Robot e Computer grazie al suo utilizzo.

\subsubsection{Il problema del controllo remoto via BlueTooth}

Bench\`e praticabile, la comunicazione via \techname{Bluetooth} soffre di
latenze che si aggirano sui $45ms$ dovute alla pessima implementazione del
\foreignword{device driver} (i cui dettagli saranno affrontati nel
Capitolo~\ref{chap:SPAMC}).

Una simile latenza di non sarebbe un problema se si volesse utilizzare
il sistema solo per il plotting o per il logging dei dati letti dai
sensori, ma \`e palesemente inadeguata in caso di implementazione di
\foreignword{PID Controller} o altri sistemi di controllo.

\subsection{Il BROFist Client per lo SPAM}\label{sec:BROClient}

Una delle parti importanti del progetto \'e stata la scrittura, lato NXT,
di un client per l'interpretazione dei \emph{BROFists}, oltre che di
controllo della velocit\'a dei motori.

\graffito{Struttura del BROFistClient}
Il client \'e formato da quattro \foreignword{task}, ognuno con il suo
compito specifico:

\begin{description}
    \item[Comunicazioni Bluetooth e Decodifica dei BROFists]utilizzando
        le definizioni per il protocollo condivise tra tutte le parti del
        progetto. Questo \'e, fondamentalmente, il nucleo dell'intero
        Client: recupera i dati richiesti dai vari sensori e setta le
        potenze o le velocit\'a da raggiungere per i singoli servomotori;
    \item[Calcolo delle velocit\'a istantanee dei motori]il quale legge
        periodicamente i dati dei sensori tachimetrici e li registra
        all'interno delle strutture contenenti i dati dei singoli
        servomotori;
    \item[Controllo della velocit\'a dei motori]tramite l'utilizzo di un
        \PID, il quale usa i dati relativi alle
        potenze ed agli errori di velocit\'a per calcolare quanta potenza
        utilizzare per far andare i motori alla velocit\'a richiesta.
    \item[Rappresentazione di dati sullo schermo]utilizzando un comando
        delle API di \nxtOSEK{}. Naturalmente questi dati possono venir
        configurati modificando il codice sorgente del client.
\end{description}

\cleardoublepage
